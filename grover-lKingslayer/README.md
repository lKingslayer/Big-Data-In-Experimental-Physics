# Grover's Algorithm

## 问题背景

### 配合问题系列而出的背景

天才少年爱迪生在找一个文件，但他的磁盘太大了（指数级），他不想遍历所有可能性，
于是他找到了你，希望你能用一个量子的先知（oracle）帮他相对快速地找到。

### 科学背景

（翻译腔十分抱歉）

假如你被给予了一个指标函数（Indicator function）f，其对2^n个可能的输入中，
某个特定的输入x表现为f(x)=1，而对于所有其他y!=x表现为f(y)=0，我们现在的工作就是
要找到这个x。对你来说，f是个黑箱，你不知道其工作原理，所以你无从逆向。

普通的做法是，对于所有的x，测试f(x)，直到某个x0使得f(x0)=1。但这个对于稍微大一
点的n来说，耗时已经相当恐怖。同学们可以试试 2^64 是在多大的数量级。

Grover算法是一种搜索算法，以n=64为例子，可以在`2^(64*0.5)`数量级的时间内，
也就是`2^32`的时间内，以高概率实现对x的确定。即进行了平方根的优化。

#### 量子比特

这是如何做到的呢？我们先来看看数的表示，以17为例子，其二进制表示为10001，用了
五个经典比特，那么在量子的世界中，我们就用五个量子比特来表示，即`|1>|0>|0>|0>|1>`，
可简写为`|10001>`。

相比于传统比特非零即一的特性，每一个量子比特可以处于0 和 1的叠加态中。

具体来说，一个量子比特可以被认为是二维希尔伯特空间中的一个向量。其完整表达可以这样表示`|psi>=a|0>+b|1>`，其中|0>，|1>为希尔伯特空间的正交归一基，a与b是0与1出现概率的相关系数，为复数，满足 |a|^2+|b|^2=1 。 对于多个量子比特，则其表示为多个二维希尔伯特空间张量积所形成的希尔伯特空间，其基为各希尔伯特空间正交基的张量积。以两个量子比特为例，|0>otimes|0>简记为|00>。


简而言之，这种表示的方式是在以希尔伯特状态空间中的四个正交向量`|00>`,`|01>`,`|10>`,`|11>`
作为基底，其余所有状态都是基底的线性叠加。

既然提到了希尔伯特空间以及正交的概念，我们就需要介绍内积。
对于 `|x>`，我们定义其共轭转置为 `<x|`（举例，若`|x>=(0 i)^T`，那么`<x|=(0 -i)`），
那么定义内积为`<x|y>`。对于x，y是基底的情况，我们有当`x=y`时，`<x|y>=1`，而当
 `x!=y`时，`<x|y>=0`，即基底是归一化的以及相互正交的。

#### 量子门

接下来讲运算。我们提到，量子计算就是对量子状态的概率系数做操控，既然状态是个向量了，
那么聪明的你一定已经想到了，我们的运算就是将矩阵作用在向量上。我们在此介绍两种特殊的矩阵，
一种叫做Hadamard门，而另一种用于实现Householder变换。

Hadamard门一般用于准备量子状态。在实际的量子系统中，我们一般容易准备的是全0的量子态，
Hadamard门的作用就是将其变换为2^n种状态叠加的量子态。Hadamard门一般记为H，对于
单量子的Hadamard门，其矩阵表示为`[[1,1],[1,-1]]/sqrt(2)`，经过简单的运算可以知道，
`H|0>=(|0>+|1>)/sqrt(2)`而`H|1>=(|0>-|1>)/sqrt(2)`。大家可以注意到，
运算后的系数依旧满足归一化的需求。

对于多个量子来说，其Hadamard门由对单个量子比特的Hadamard门组合而成，例如对于两个量子比特，
我们有 `H_1\otimesH_2|00>=(|0>+|1>)(|0>+|1>)=|00>+|01>+|10>+|11>`（省去归一化系数），
这个总的Hadamard门的矩阵表示就是将两个单个量子比特的Hadamard门矩阵张量积（克罗内克积）而成，
其形状为4x4。之所以是张量积而成，是因为量子态的向量表示也是张量积而成的。

第二种要介绍的门可以用来实现Householder运算，这是Grover算法的核心部件。
我们首先介绍一种特殊的运算符号，以单量子比特为例子，我们介绍`|0><1|`，
这种符号是由`|0>`与`<1|`外积而成，矩阵表示是 `[[0,1],[0,0]]`，其实现的功能是
将`|1>`状态向量变为`|0>`，即 `|0><1||1>=|0><1|1>=|0>`。

我们使用这样一个状态 `|s>=H^{\otimes n}|0>=\sum_{i=0}^{2^n-1}|i>`，即对n个量子比特做一次n 量子比特Hadamard门，使得状态
变为2^n种状态的均匀叠加，然后我们定义一个门`U_s=2|s><s|-I`，其中I为单位矩阵。
根据Householder变换的集合意义，我们知道，这个门将输入的状态沿着`|s>`做对称
变换。从数学上来说，对于任意一个输入状态，我们可以拆成 `|s>+|s'>`（省略系数）
其中`|s'>`与`|s>`正交，我们有 `U_s(|s>+|s'>)=|s>-|s'>`，即对称变换。

同理，我们对于一个状态`|w>`，我们可以定义一个新的门 `U_w=I-2|w><w|`，对于所有
状态 `|w>+|w'>`（省略系数），我们有 `U_w(|w>+|w'>)=-|w>+|w'>`。

#### 算法本体

有了门，我们就有了算法的基本组件了！你可能注意到了上面的重点，Householder变换有
几何上的意义。这个算法其实就是几何上的。

```
|w>  |s>=|phi0>
 |  /
 | /
 |/ theta
 +-----|w'>
```

如图所示，`|w>`与`|w'>`正交，`|s>`夹在两个向量的中间，与`|w'>`成`theta`角。
当我们对 `|phi0>=|s>` 应用一次 `U_w`，然后应用一次 `U_s`，我们可以得到
`|phi1>`，经过计算（这里还是贴一下公式），我们知道`|phi1>`与`|w'>`成`3theta`角度。
对`|phi1>`再应用`U_w`与`U_s`之后，我们发现其角度变为 `5theta`。
以此类推，当应用了T次后，角度变为`(2T+1)theta`，当这个角度足够大时，得到的
`|phiT>`与`|w>`非常接近了，这时候我们就可以测量以获取`w`的具体数值。

那么T取多大呢？根据题意，我们知道`|w>`是基底，而不是两个基底的线性叠加，
那么`|w'>`就是其他非w的基底的线性叠加，即`|w'>=sum_z |z>`（省略系数），一共有
(2^n-1)项，经过内积，我们知道 `cos(theta)=<w'|s>=sqrt[(2^n-1)/2^n]`,
`sin(theta)=sqrt(1/2^n)=theta`，我们需要取T，使得`(2T+1)theta=pi/2`，那么
`T=pi*sqrt(2^n)/4`。

至此，背景介绍完

## 问题描述

在上述算法中，我们注意到`U_w`的存在，其依赖于`|w>`，但`|w>`即为我们所需要搜索的项，作为一个搜索算法，`U_w`必须不是自己构建的，而是一个先知（oracle），由外部输入。

我们提供一个oracle.py，在其中实现了函数`Uw`，并提供了`n`表示需要多少个量子比特，在你的程序中，你需要在你的程序中将其导入（参见代码框架），同时你需要自行实现`Us`，实现预处理过程与运算过程，并将计算后的概率最大元素的下标在标准输出中输出。

## 样例与评测

样例可以参考直接给出的oracle.py，也可参考data目录下系列oracle文件。

在自行评测时，评测脚本会将data/中的oracle移动到主目录下，替换掉原有的oracle。

虽然在这里，你可以直接测量`Uw`而得到`w`的具体数值，但在在现实情况中这是不能实现的，所以我们禁止这种做法的存在。

我们在 `data` 目录下提供了八组数据，分别对应不同的情况和数据量大小。和之前的题目一样，你可以通过 `python3 grade.py` 来进行一次的本地测评。

这次会考验你代码编写的效率，如果代码运行的不够快，可能不到黑盒的满分。本题设置了 1s 的时间限制，如果超过了这个时间，评测程序会提示你超时；对于未超时的数据，它会输出你的代码的实际用时。

最终评分以在助教机器上运行的时间为准。所用电脑的 CPU 为 Intel Core i7-8750H。

最终分数构成为：

* 黑盒 80 分：共 8 个测例，每个 10 分
* 白盒 20 分：代码风格（评测不参考pylint，推荐大家自用pylint），Git 使用 20 分（包括恰当注释（一句话一个注释者，倒扣）、合理命名、提交日志等）

助教以 deadline 前 GitHub 上最后一次提交为准进行评测。
